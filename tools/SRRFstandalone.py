# -*- coding: utf-8 -*-
"""SRRFandQC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/HenriquesLab/NanoPyx/blob/main/notebooks/SRRFandQC.ipynb
"""

#@title Fix OpenCL if needed in Google Colab
import sys

#IN_COLAB = 'google.colab' in sys.modules
'''if IN_COLAB:
    !sudo apt-get update -qq
    !sudo apt-get purge -qq *nvidia* -y
    !sudo DEBIAN_FRONTEND=noninteractive apt-get install -qq nvidia-driver-530 -y
    exit(0)

#@title Install NanoPyx, import necessary libraries and connect to Google Drive
!pip install -q "nanopyx[jupyter]"
'''
import io
import os
import sys
import cv2 as cv
import skimage
import nanopyx
import stackview
import numpy as np
import tifffile as tiff
import matplotlib as mpl
import ipywidgets as widgets
from PIL import Image
from IPython.display import display, clear_output
from matplotlib import pyplot as plt

from nanopyx.methods import SRRF
from nanopyx.core.transform.sr_temporal_correlations import calculate_SRRF_temporal_correlations
from nanopyx.core.utils.easy_gui import EasyGui
from nanopyx.core.utils.find_files import find_files
from nanopyx.data.download import ExampleDataManager


"""# NanoPyx "Codeless" 
# Use SRRF to generate a super-resolved image
# SRRF Parameters:

- **Ring Radius:** Radius of the ring used to calculate the radiality (in pixels).
- **Magnification:** Desired magnification for the generated radiality image.
- **SRRF order:** Flag for types of SRRF temporal correlations. Order = -1: pairwise product sum; Order = 0: maximum intensity projection; Order = 1: mean; Order = 2,3 or 4: autocorrelation function of order 2, 3 or 4.
- **Frames-per-timepoint:** How many frames of the original image stack are used to calculated a single SRRF frame. For example, given an input image with 500 frames, if using 100 frames per timepoint, SRRF will generate an image stack with 5 super-resolved frames.
"""

dataset_original = tif.imread("dataset_original")

ring_radius = 1
magnification = 5
frames_per_timepoint = 10
srrf_order = 2
# disable button while running
if frames_per_timepoint == 0:
    frames_per_timepoint = dataset_original.shape[0]
elif frames_per_timepoint > dataset_original.shape[0]:
    frames_per_timepoint = dataset_original.shape[0]

output= []
for i in range(dataset_original.shape[0] // frames_per_timepoint):
    block = dataset_original[i*frames_per_timepoint:(i+1)*frames_per_timepoint]
    result = SRRF(block, magnification=magnification, ringRadius=ring_radius,
                            radialityPositivityConstraint=True,
                            doIntensityWeighting=True)
    output.append(calculate_SRRF_temporal_correlations(result[0], srrf_order))

dataset_srrf = np.array(output)
tiff.imwrite(path + os.sep + name + "_srrf.tif", dataset_srrf)
"""## Calculate error map for the SRRF image


"""

#@title Create Error Map GUI
gui_error = EasyGui("Error")

import numpy as np
from matplotlib import pyplot as plt
from nanopyx.core.transform import ErrorMap

def run_error(b):
    clear_output()
    gui_error.show()
    gui_error.save_settings()
    gui_error["run"].disabled = True
    gui_error["run"].description = "Calculating..."
    global errormap
    error_map = ErrorMap()
    error_map.optimise(np.mean(dataset_original, axis=0), np.mean(dataset_srrf, axis=0))
    gui_error["run"].disabled = False
    gui_error["run"].description = "Calculate"
    print("RSE: ", error_map.getRSE())
    print("RSP: ", error_map.getRSP())
    errormap = np.array(error_map.imRSE)
    if gui_error["save"].value:
        if own_data:
            path = gui_data["upload"].selected_path
            name = gui_data["upload"].selected_filename.split(".")[0]
            tiff.imwrite(path + os.sep + name + "_error_map.tif", errormap)
        else:
            name = gui_data["data_source"].value.replace("Example dataset: ", "")
            tiff.imwrite(name + "_error_map.tif", errormap)
    plt.imshow(errormap)
    plt.axis("off")
    img_buf = io.BytesIO()
    plt.savefig(img_buf, format="jpeg")
    output_plot = widgets.Output()
    with output_plot:
        display(Image.open(img_buf))
    gui_error._main_display.children = gui_error._main_display.children + (
        widgets.Label(value="RSE: "+str(error_map.getRSE())),
        widgets.Label(value="RSP: "+str(error_map.getRSP())),
        output_plot)
    plt.clf()


gui_error.add_checkbox("save", description="Save output", value=True)
gui_error.add_dropdown("cmaps", description="Colormap:",
                       options=sorted(list(mpl.colormaps)),
                       value="viridis", remember_value=True)
gui_error.add_button("run", description="Calculate")
gui_error["run"].on_click(run_error)
gui_error.show()

"""## Calculate FRC resolution of the diffraction limited image
# FRC Parameters:

- **Pixel Size:** Pixel size of the image. Used to calculte resolution values.
- **Units:** Pixel size units.
- **First/Second Frame:** As FRC is calculated between two frames of the same image stack, these parameters determines which two frames are used for the calculation.



"""

#@title create FRC GUI for original image
gui_frc_df = EasyGui("FRC")

import numpy as np
from nanopyx.core.analysis.frc import FIRECalculator

def run_frc(b):
    clear_output()
    gui_frc_df.show()
    gui_frc_df.save_settings()
    pixel_size = gui_frc_df["pixel_size"].value
    units = gui_frc_df["units"].value
    first_frame = gui_frc_df["first_frame"].value
    second_frame = gui_frc_df["second_frame"].value
    gui_frc_df["run"].disabled = True
    gui_frc_df["run"].description = "Calculating..."
    global frc_calculator_raw
    frc_calculator_raw = FIRECalculator(pixel_size=pixel_size, units=units)
    frc_calculator_raw.calculate_fire_number(dataset_original[first_frame], dataset_original[second_frame])
    gui_frc_df["run"].disabled = False
    gui_frc_df["run"].description = "Calculate"
    plot = frc_calculator_raw.plot_frc_curve()
    if gui_frc_df["save"].value:
        if own_data:
            path = gui_data["upload"].selected_path
            name = gui_data["upload"].selected_filename.split(".")[0]
            tiff.imwrite(path + os.sep + name + "_original_FRC.tif", plot)
        else:
            name = gui_data["data_source"].value.replace("Example dataset: ", "")
            tiff.imwrite(name + "_FRC_df.tif", plot)
    plt.imshow(plot)
    plt.axis("off")
    img_buf = io.BytesIO()
    plt.savefig(img_buf, format="jpeg")
    output_plot = widgets.Output()
    with output_plot:
        display(Image.open(img_buf))
    gui_frc_df._main_display.children = gui_frc_df._main_display.children + (output_plot,)
    plt.clf()

gui_frc_df.add_int_slider("pixel_size", description="Pixel Size:", min=0.01, max=1000, value=100, remember_value=True)
gui_frc_df.add_dropdown("units", description="Units: ", options=["nm", "um", "mm"], value="nm")
gui_frc_df.add_int_slider("first_frame", description="First Frame:", min=0, max=dataset_original[0].shape[0]-1, value=0)
gui_frc_df.add_int_slider ("second_frame", description="Second Frame:", min=0, max=dataset_original[0].shape[0]-1, value=1)
gui_frc_df.add_checkbox("save", description="Save Output", value=True)
gui_frc_df.add_button("run", description="Calculate")
gui_frc_df["run"].on_click(run_frc)
gui_frc_df.show()

"""## Calculate FRC resolution of the SR image
# FRC Parameters:

- **Pixel Size:** Pixel size of the image. Used to calculte resolution values.
- **Units:** Pixel size units.
- **First/Second Frame:** As FRC is calculated between two frames of the same image stack, these parameters determines which two frames are used for the calculation.



"""

#@title create FRC GUI for SR image
gui_frc_srrf = EasyGui("FRC")

import numpy as np
from nanopyx.core.analysis.frc import FIRECalculator

def run_frc(b):
    clear_output()
    gui_frc_srrf.show()
    gui_frc_srrf.save_settings()
    pixel_size = gui_frc_srrf["pixel_size"].value
    units = gui_frc_srrf["units"].value
    first_frame = gui_frc_srrf["first_frame"].value
    second_frame = gui_frc_srrf["second_frame"].value
    gui_frc_srrf["run"].disabled = True
    gui_frc_srrf["run"].description = "Calculating..."
    global frc_calculator_raw
    frc_calculator_raw = FIRECalculator(pixel_size=pixel_size, units=units)
    frc_calculator_raw.calculate_fire_number(dataset_srrf[first_frame], dataset_srrf[second_frame])
    gui_frc_srrf["run"].disabled = False
    gui_frc_srrf["run"].description = "Calculate"
    plot = frc_calculator_raw.plot_frc_curve()
    if gui_frc_srrf["save"].value:
        if own_data:
            path = gui_data["upload"].selected_path
            name = gui_data["upload"].selected_filename.split(".")[0]
            tiff.imwrite(path + os.sep + name + "_original_FRC.tif", plot)
        else:
            name = gui_data["data_source"].value.replace("Example dataset: ", "")
            tiff.imwrite(name + "_FRC_df.tif", plot)
    plt.imshow(plot)
    plt.axis("off")
    img_buf = io.BytesIO()
    plt.savefig(img_buf, format="jpeg")
    output_plot = widgets.Output()
    with output_plot:
        display(Image.open(img_buf))
    gui_frc_srrf._main_display.children = gui_frc_srrf._main_display.children + (output_plot,)
    plt.clf()

gui_frc_srrf.add_int_slider("pixel_size", description="Pixel Size:", min=0.01, max=1000, value=100, remember_value=True)
gui_frc_srrf.add_dropdown("units", description="Units: ", options=["nm", "um", "mm"], value="nm")
gui_frc_srrf.add_int_slider("first_frame", description="First Frame:", min=0, max=dataset_srrf[0].shape[0]-1, value=0)
gui_frc_srrf.add_int_slider ("second_frame", description="Second Frame:", min=0, max=dataset_srrf[0].shape[0]-1, value=1)
gui_frc_srrf.add_checkbox("save", description="Save Output", value=True)
gui_frc_srrf.add_button("run", description="Calculate")
gui_frc_srrf["run"].on_click(run_frc)
gui_frc_srrf.show()

"""## Calculate Decorrelation analysis resolution of the diffraction limited image
# Image Decorrelation Analysis Parameters:

- **Pixel Size:** Pixel size of the image. Used to calculte resolution values.
- **Units:** Pixel size units.
- **Frame:** Frame to be used for decorrelation analysis
- **Radius Min/Max:** Resolution calculation by Decorrelation Analysis is performed in the frequency space. These parameters define the range of radii to be used in the calculation.



"""

#@title Create Decorrelation Analysis GUI for eSRRF data
gui_decorr_df = EasyGui("DecorrAnalysis")

from nanopyx.core.analysis.decorr import DecorrAnalysis

def run_decorr(b):
    clear_output()
    gui_decorr_df.show()
    gui_decorr_df.save_settings()
    pixel_size = gui_decorr_df["pixel_size"].value
    units = gui_decorr_df["units"].value
    first_frame = gui_decorr_df["first_frame"].value
    rmin = gui_decorr_df["rmin"].value
    rmax = gui_decorr_df["rmax"].value
    gui_decorr_df["run"].disabled = True
    gui_decorr_df["run"].description = "Calculating..."
    global decorr_calculator
    decorr_calculator = DecorrAnalysis(pixel_size=pixel_size, units=units, rmin=rmin, rmax=rmax)
    decorr_calculator.run_analysis(dataset_original[first_frame])
    gui_decorr_df["run"].disabled = False
    gui_decorr_df["run"].description = "Calculate"
    plot = decorr_calculator.plot_results()
    if gui_decorr_df["save"].value:
        if own_data:
            path = gui_data["upload"].selected_path
            name = gui_data["upload"].selected_filename.split(".")[0]
            tiff.imwrite(path + os.sep + name + "_eSRRF_decorr_analysis.tif", plot)
        else:
            name = gui_data["data_source"].value.replace("Example dataset: ", "")
            tiff.imwrite(name + "_eSRRF_decorr_analysis.tif", plot)
    plt.imshow(plot)
    plt.axis("off")
    img_buf = io.BytesIO()
    plt.savefig(img_buf, format="jpeg")
    output_plot = widgets.Output()
    with output_plot:
        display(Image.open(img_buf))
    gui_decorr_df._main_display.children = gui_decorr_df._main_display.children + (output_plot,)
    plt.clf()

gui_decorr_df.add_int_slider("pixel_size", description="Pixel Size:", min=0.01, max=1000, value=100, remember_value=True)
gui_decorr_df.add_dropdown("units", description="Units: ", options=["nm", "um", "mm"], value="nm")
gui_decorr_df.add_int_slider("first_frame", description="Frame to be used:", min=0, max=dataset_original.shape[0]-1, value=0)
gui_decorr_df.add_float_slider("rmin", description="Radius Min:", min=0.0, max=0.5, value=0.0)
gui_decorr_df.add_float_slider("rmax", description="Radius Max:", min=0.5, max=1.0, value=1.0)
gui_decorr_df.add_checkbox("save", description="Save Output", value=True)
gui_decorr_df.add_button("run", description="Calculate")
gui_decorr_df["run"].on_click(run_decorr)
gui_decorr_df.show()

"""## Calculate Decorrelation analysis resolution of the SR image
# Image Decorrelation Analysis Parameters:

- **Pixel Size:** Pixel size of the image. Used to calculte resolution values.
- **Units:** Pixel size units.
- **Frame:** Frame to be used for decorrelation analysis
- **Radius Min/Max:** Resolution calculation by Decorrelation Analysis is performed in the frequency space. These parameters define the range of radii to be used in the calculation.



"""

#@title Create Decorrelation Analysis GUI for eSRRF data
gui_decorr = EasyGui("DecorrAnalysis")

from nanopyx.core.analysis.decorr import DecorrAnalysis

def run_decorr(b):
    clear_output()
    gui_decorr.show()
    gui_decorr.save_settings()
    pixel_size = gui_decorr["pixel_size"].value
    units = gui_decorr["units"].value
    first_frame = gui_decorr["first_frame"].value
    rmin = gui_decorr["rmin"].value
    rmax = gui_decorr["rmax"].value
    gui_decorr["run"].disabled = True
    gui_decorr["run"].description = "Calculating..."
    global decorr_calculator
    decorr_calculator = DecorrAnalysis(pixel_size=pixel_size, units=units, rmin=rmin, rmax=rmax)
    decorr_calculator.run_analysis(dataset_srrf[first_frame])
    gui_decorr["run"].disabled = False
    gui_decorr["run"].description = "Calculate"
    plot = decorr_calculator.plot_results()
    if gui_decorr["save"].value:
        if own_data:
            path = gui_data["upload"].selected_path
            name = gui_data["upload"].selected_filename.split(".")[0]
            tiff.imwrite(path + os.sep + name + "_eSRRF_decorr_analysis.tif", plot)
        else:
            name = gui_data["data_source"].value.replace("Example dataset: ", "")
            tiff.imwrite(name + "_eSRRF_decorr_analysis.tif", plot)
    plt.imshow(plot)
    plt.axis("off")
    img_buf = io.BytesIO()
    plt.savefig(img_buf, format="jpeg")
    output_plot = widgets.Output()
    with output_plot:
        display(Image.open(img_buf))
    gui_decorr._main_display.children = gui_decorr._main_display.children + (output_plot,)
    plt.clf()

gui_decorr.add_int_slider("pixel_size", description="Pixel Size:", min=0.01, max=1000, value=100, remember_value=True)
gui_decorr.add_dropdown("units", description="Units: ", options=["nm", "um", "mm"], value="nm")
gui_decorr.add_int_slider("first_frame", description="Frame to be used:", min=0, max=dataset_srrf.shape[0]-1, value=0)
gui_decorr.add_float_slider("rmin", description="Radius Min:", min=0.0, max=0.5, value=0.0)
gui_decorr.add_float_slider("rmax", description="Radius Max:", min=0.5, max=1.0, value=1.0)
gui_decorr.add_checkbox("save", description="Save Output", value=True)
gui_decorr.add_button("run", description="Calculate")
gui_decorr["run"].on_click(run_decorr)
gui_decorr.show()